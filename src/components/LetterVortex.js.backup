import React, { useRef, useState } from 'react';
import { Canvas, useFrame, useThree } from '@react-three/fiber';
import { Text } from '@react-three/drei';
import * as THREE from 'three';

// Стабильный псевдо-рандом на основе индекса (одинаков при каждом рендере)
const fract = (x) => x - Math.floor(x);
const seeded01 = (i, seed = 0.618) => {
  const x = Math.sin(i * 12.9898 + seed) * 43758.5453;
  return fract(x);
};

// Local Vortex Canvas (style like StarsCanvas, slower)
const LocalVortexCanvas = ({ count = 260 }) => {
  const canvasRef = useRef(null);
  const starsRef = useRef([]);
  const startedAt = useRef(performance.now());

  const resize = () => {
    const canvas = canvasRef.current;
    if (!canvas || !canvas.parentElement) return;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const rect = canvas.parentElement.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect?.width || 280));
    const h = Math.max(1, Math.floor(rect?.height || 280));
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    const ctx = canvas.getContext('2d');
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  };

  const makeStars = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const cx = w / 2;
    const cy = h / 2;
    const amount = Math.round(count);
    const arr = new Array(amount).fill(0).map(() => {
      const x0 = Math.random() * w;
      const y0 = Math.random() * h;
      const vx = x0 - cx;
      const vy = y0 - cy;
      const baseAngle = Math.atan2(vy, vx);
      const baseRadius = Math.hypot(vx, vy);
      return {
        baseAngle,
        baseRadius,
        r: 0.9 + Math.random() * 1.6,
        baseAlpha: 0.65 + Math.random() * 0.35,
        angVel: (0.003 + Math.random() * 0.012) * (Math.random() < 0.5 ? -1 : 1),
        wobbleAmp: 1.6 + Math.random() * 3.5,
        wobbleFreq: 0.18 + Math.random() * 0.5,
        wobblePhase: Math.random() * Math.PI * 2,
        pulseFreq: 0.35 + Math.random() * 0.6,
        pulsePhase: Math.random() * Math.PI * 2,
        personalSpin: (Math.random() * 0.01) * (Math.random() < 0.5 ? -1 : 1),
        tint: Math.random(),
      };
    });
    starsRef.current = arr;
  };

  React.useEffect(() => {
    resize();
    makeStars();
    const onResize = () => { resize(); makeStars(); };
    window.addEventListener('resize', onResize);
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');

    // Отслеживаем реальные изменения размеров родителя (в т.ч. при гидрации/пересчёте макета)
    let ro;
    if (canvas && canvas.parentElement && 'ResizeObserver' in window) {
      ro = new ResizeObserver(() => {
        resize();
        makeStars();
      });
      ro.observe(canvas.parentElement);
    }
    let rafId;
    const render = (now) => {
      const t = (now - startedAt.current) / 1000;
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      const cx = w / 2;
      const cy = h / 2;
      ctx.clearRect(0, 0, w, h);
      const globalAngle = t * 0.0015; // slower than page bg
      for (const s of starsRef.current) {
        const angle = s.baseAngle + globalAngle + t * s.angVel + t * s.personalSpin;
        const wobble = s.wobbleAmp * Math.sin(t * s.wobbleFreq + s.wobblePhase);
        const r = Math.max(0, s.baseRadius + wobble);
        const x = cx + Math.cos(angle) * r;
        const y = cy + Math.sin(angle) * r;
        const pulse = 0.6 + 0.4 * Math.sin(t * s.pulseFreq + s.pulsePhase);
        const c1 = `rgba(76,29,149,${0.18 * s.baseAlpha * pulse})`;
        const c2 = `rgba(124,58,237,${0.28 * s.baseAlpha * pulse})`;
        ctx.fillStyle = Math.random() < s.tint ? c2 : c1;
        ctx.beginPath();
        ctx.arc(x, y, s.r, 0, Math.PI * 2);
        ctx.fill();
      }
      rafId = requestAnimationFrame(render);
    };
    rafId = requestAnimationFrame(render);
    return () => {
      window.removeEventListener('resize', onResize);
      if (ro) try { ro.disconnect(); } catch {}
      if (rafId) cancelAnimationFrame(rafId);
    };
  }, [count]);

  return <canvas ref={canvasRef} className="w-full h-full block" style={{ background: 'transparent', backgroundColor: 'transparent' }} />;
};

// Orbiting Letters Component (те же 26 букв, разбитые на 3 кольца)
const OrbitingLetters = () => {
  const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split(''); // 26 букв, как было
  const mouse = useRef({ x: 0, y: 0 });
  const ringRefs = useRef([]);
  const speedsRef = useRef([0.12, 0.16, 0.2]);
  const ringAnglesRef = useRef([0, 0, 0]);
  const letterRefs = useRef([]);
  const { viewport, mouse: threeMouse } = useThree();
  const [, forceUpdate] = useState({});

  useFrame((state, delta) => {
    // Обновляем позицию мыши правильно
    mouse.current.x = threeMouse.x * 2;
    mouse.current.y = threeMouse.y * 2;

    // Принудительно перерендериваем для анимации
    // advance per-ring angles and move letters along fixed ellipses
    const speeds = speedsRef.current;
    const ringAngles = ringAnglesRef.current;
    for (let i = 0; i < 3; i++) {
      ringAngles[i] = (ringAngles[i] + speeds[i] * delta) % (Math.PI * 2);
    }

    // Простые радиусы от маленького к большому
    const r0 = (baseRadius + stepRadius) * 1.10 * 1.15 * 1.4; // 2.037 (внешнее кольцо)
    const r1 = (baseRadius + stepRadius * 1.4) * 1.4; // 1.75 (внутреннее кольцо)
    const r2 = 1.78; // (среднее кольцо)

    const lettersLen = letters.length;
    for (let ring = 0; ring < 3; ring++) {
      const indices = ringIndices[ring];
      for (let k = 0; k < indices.length; k++) {
        const index = indices[k];
        const radius = ring === 0 ? r1 : (ring === 1 ? r2 : r0);
        let radiusX, radiusY;
        if (ring === 0) {
          radiusX = radius * 0.67;
          radiusY = radius;
        } else {
          radiusX = radius;
          radiusY = radius * 1.2;
        }
        const angle = (index / lettersLen) * Math.PI * 2 + ringAngles[ring];
        const cosA = Math.cos(angle);
        const sinA = Math.sin(angle);
        const baseX = radiusX * cosA;
        
        const baseY = sinA * radiusY;
        const distanceToMouse = Math.hypot(baseX - mouse.current.x, baseY - mouse.current.y);
        const maxDistance = 3;
        const attraction = Math.max(0, 1 - distanceToMouse / maxDistance);
        let x = baseX, y = baseY;
        if (attraction > 0.1) {
          const pullStrength = attraction * 0.4;
          x = baseX + (mouse.current.x - baseX) * pullStrength;
          y = baseY + (mouse.current.y - baseY) * pullStrength;
        } else if (distanceToMouse > maxDistance) {
          const pushStrength = 0.15;
          x = baseX * (1 - pushStrength);
          y = baseY * (1 - pushStrength);
        }
        const z = Math.sin(index) * 0.15;
        const uniqueSeed = ring * 1000 + index * 17.3456;
        const rotationZ = angle + (Math.sin(uniqueSeed) - 0.5) * 2 * (Math.PI / 3);
        const g = letterRefs.current[index];
        if (g) {
          g.position.set(x, y, z);
          g.rotation.set(0, 0, rotationZ);
        }
      }
    }
  });

  // Функция для получения текущего вращения кольца
  const getRingRotation = (ring, time) => {
    const speeds = [0.0054, 0.0057, 0.00642]; // скорости для каждого кольца
    return time * speeds[ring];
  };

  // Разбиваем индексы на 3 массива так, как это делала формула radius = base + (index % 3)*step
  const ringIndices = React.useMemo(() => {
    const r0 = [], r1 = [], r2 = [];
    for (let i = 0; i < letters.length; i++) {
      if (i % 3 === 0) r0.push(i);
      else if (i % 3 === 2) r1.push(i); // среднее кольцо (между 0 и 2)
      else r2.push(i);
    }
    return [r0, r1, r2];
  }, [letters.length]);

  const baseRadius = 0.9; // уменьшенный базовый радиус
  const stepRadius = 0.25; // уменьшенный шаг между кольцами

  return (
    <group>
      {ringIndices.map((indices, ring) => (
        <group key={ring} ref={(el) => (ringRefs.current[ring] = el)}>
          {indices.map((index, positionInRing) => {
            const letter = letters[index];
            // Простые радиусы от маленького к большому
            const r0_init = (baseRadius + stepRadius) * 1.10 * 1.15 * 1.4; // 2.037 (внешнее кольцо)
            const r1_init = (baseRadius + stepRadius * 1.4) * 1.4; // 1.75 (внутреннее кольцо)
            const r2_init = 1.78; // (среднее кольцо)
            const radius = ring === 0 ? r1_init : (ring === 1 ? r2_init : r0_init); // исправленное распределение по кольцам

            // Угол с учетом вращения кольца
            const currentTime = Date.now() * 0.001; // текущее время в секундах
            const ringRotation = getRingRotation(ring, currentTime);
            const angle = (index / letters.length) * Math.PI * 2;

            // Фиксированная форма орбиты (не вращается с кольцом)
            let radiusX, radiusY;
            if (ring === 0) {
              // соотношение эллипса для внутреннего кольца
              radiusX = radius * 0.67;
              radiusY = radius;
            } else {
              // соотношение эллипса для внешних колец
              radiusX = radius;
              radiusY = radius * 1.2;
            }

            const cosA = Math.cos(angle);
            const sinA = Math.sin(angle);
            const baseX = radiusX * cosA;
            
            const baseY = sinA * radiusY;

            // Эффект притяжения к курсору
            const distanceToMouse = Math.hypot(baseX - mouse.current.x, baseY - mouse.current.y);
            const maxDistance = 3; // Радиус влияния курсора
            const attraction = Math.max(0, 1 - distanceToMouse / maxDistance);

            // Ближние к курсору: притяжение к курсору
            // Дальние: смещение к внутреннему кольцу
            let x = baseX;
            let y = baseY;

            if (attraction > 0.1) {
              // Притяжение к курсору (заметный эффект)
              const pullStrength = attraction * 0.4;
              x = baseX + (mouse.current.x - baseX) * pullStrength;
              y = baseY + (mouse.current.y - baseY) * pullStrength;
            } else if (distanceToMouse > maxDistance) {
              // Дальние буквы смещаются к внутреннему кольцу
              const pushStrength = 0.15;
              x = baseX * (1 - pushStrength);
              y = baseY * (1 - pushStrength);
            }

            const z = Math.sin(index) * 0.15; // прежний небольшой рельеф
            // Уникальный поворот для каждого кольца и позиции в кольце
            const uniqueSeed = ring * 1000 + positionInRing * 17.3456;
            const randomRotationOffset = (Math.sin(uniqueSeed) - 0.5) * 2 * (Math.PI / 3);
            // Уменьшенные размеры букв + перспектива
            const baseFontSizes = [0.12, 0.15, 0.18]; // внутреннее, среднее, внешнее - все меньше
            const baseFontSize = baseFontSizes[ring];
            // Увеличение размера при приближении к курсору
            const sizeBoost = attraction * 0.04;
            const fontSize = baseFontSize + sizeBoost;

            const hue = 180 + index * 7;
            const light = 70 + (index % 3) * 15;
            return (
              <group ref={(el) => (letterRefs.current[index] = el)} key={index} position={[x, y, z]} rotation={[0, 0, angle + randomRotationOffset]}>
                <Text
                  fontSize={fontSize}
                  color={`hsl(${hue}, 70%, ${light}%)`}
                  anchorX="center"
                  anchorY="middle"
                  font="/fonts/ShadowsIntoLight-Regular.ttf"
                >
                  {letter}
                  <meshStandardMaterial
                    emissive={new THREE.Color(`hsl(${hue}, 50%, 35%)`)}
                    emissiveIntensity={0.6}
                  />
                </Text>
              </group>
            );
          })}
        </group>
      ))}
    </group>
  );
};

// Main Letter Vortex Component
const LetterVortex = () => {
  return (
    <div className="absolute inset-0 pointer-events-none overflow-visible z-20">
      {/* 3D Canvas Background - vortex */}
      <div
        className="absolute pointer-events-none z-20"
        style={{
          top: '50%',
          left: '50%',
          width: '240%',
          height: '240%',
          transform: 'translate(-50%, -50%)'
        }}
      >
        <LocalVortexCanvas count={300} />
      </div>

      {/* 3D Letters Canvas */}
      <div
        className="absolute pointer-events-none z-20"
        style={{
          top: '50%',
          left: '50%',
          width: '350%',
          height: '350%',
          transform: 'translate(-50%, -50%)'
        }}
      >
        <Canvas
          camera={{ position: [0, 0, 4.2], fov: 48 }}
          style={{ width: '100%', height: '100%', background: 'transparent', backgroundColor: 'transparent', pointerEvents: 'none' }}
          gl={{ alpha: true, antialias: true }}
          onCreated={(state) => {
            state.gl.setClearColor(0x000000, 0);
            state.gl.domElement.style.background = 'transparent';
            state.gl.domElement.style.backgroundColor = 'transparent';
          }}
        >
          <ambientLight intensity={0.32} />
          <pointLight position={[8, 8, 10]} intensity={0.55} />
          <group scale={[0.8, 0.8, 0.8]}>
            <OrbitingLetters />
          </group>
        </Canvas>
      </div>
    </div>
  );
};

export default LetterVortex;

